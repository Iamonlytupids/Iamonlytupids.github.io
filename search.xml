<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CF721C题解</title>
      <link href="/2019/08/01/CF721C%E9%A2%98%E8%A7%A3/"/>
      <url>/2019/08/01/CF721C%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p></p><h1 id="题目简述"><a href="#题目简述" class="headerlink" title="题目简述"></a>题目简述</h1><p>一座城市里有 $n$ 个景点,景点从 $1$ 到 $n$ 进行编号有些景点之间设有单向的道路,Irina经过 $i$ 道路要时间 $t_i$ ,这 $n$ 个城市和这些道路形成无环图,Irina从 $1$ 号景点出发到 $n$ 号景点Irina想知道在行驶总时间不超过 $T$ 的情况下最多能游览几个景点(前提是他要到达 $n$ 号景点),以及他游览最多景点时依次经过的景点(包括 $1$ 和 $n$ )</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>首行三个数 $n,m,T(2\leq n \leq 5000, 1 \leq m \leq 5000,1\leq T \leq 10^9)$ 随后 $m$ 行里每行三个数 $u_i,v_i,t_i(1\leq u_i,v_i \leq n,u_i \ne v_i,1\leq t_i \leq 10^9)$ 表示景点 $u_i$ 和景点 $v_i$ 之间有一条从 $u_i$ 到 $v_i$ 的有向道路,Irina需要花时间 $t_i$ 经过这条道路</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>第一行输出 $k(2\leq k \leq n)$ ,数据保证有解. 第二行输出从 $1$ 到 $n$ 依次经过的景点编号，每两个景点编号之间有空格</p><p></p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h4 id="输入1"><a href="#输入1" class="headerlink" title="输入1"></a>输入1</h4><blockquote><p>4 3 13<br>1 2 5<br>2 3 7<br>2 4 8</p></blockquote><h4 id="输出1"><a href="#输出1" class="headerlink" title="输出1"></a>输出1</h4><blockquote><p>3<br>1 2 4 </p></blockquote><h4 id="输入2"><a href="#输入2" class="headerlink" title="输入2"></a>输入2</h4><blockquote><p>6 6 7<br>1 2 2<br>1 3 3<br>3 6 3<br>2 4 2<br>4 6 2<br>6 5 1</p></blockquote><h4 id="输出2"><a href="#输出2" class="headerlink" title="输出2"></a>输出2</h4><blockquote><p>4<br>1 2 4 6 </p></blockquote><h4 id="输入3"><a href="#输入3" class="headerlink" title="输入3"></a>输入3</h4><blockquote><p>5 5 6<br>1 3 3<br>3 5 3<br>1 2 2<br>2 4 3<br>4 5 2</p></blockquote><h4 id="输出3"><a href="#输出3" class="headerlink" title="输出3"></a>输出3</h4><blockquote><p>3<br>1 3 5 </p></blockquote><p>因为是有向无环图，我们可以将该图的拓扑排序,</p><p></p><p> $dp[i][j]$ 表示从 $ 1 $ 到 $i$ 的路程中经过 $j$ 个点(包括 $ 1 $ 和 $ i $ )的最短路径,通过拓扑序进行dp即可.</p><p></p><p></p><p>$$ dp[i][j]=\min_{ver[k][i]=1}(dp[k][j-1]) $$</p><p>设初值 $dp[1][1]=1$</p><p></p><p></p><p>时间复杂度为 $O(nm)$</p><p></p><p>代码:</p><pre><code class="C++">#include &lt;bits/stdc++.h&gt;#define maxn 5010#define inf 1000000001#define rei register int#define rel register llusing namespace std;struct node{    int to,next,w;}edge[maxn],n_edge[maxn];int n,m,t;int head[maxn],tot,n_tot,n_head[maxn];int entry[maxn];int dp[maxn][maxn],prevv[maxn][maxn];void add(int u,int v,int w){    edge[++tot].to=v,edge[tot].next=head[u],edge[tot].w=w,head[u]=tot;     n_edge[++n_tot].to=u,n_edge[n_tot].next=n_head[v],n_edge[n_tot].w=w,n_head[v]=n_tot;}int main(){    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;t);    for(rei i=1;i&lt;=m;++i){        int u,v,w;        scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);        add(u,v,w);        ++entry[v];    }    for(rei i=0;i&lt;=n;++i)     for(rei j=0;j&lt;=n;++j)      dp[i][j]=inf;    int q[maxn],hhead=1,tail=0;    for(rei i=1;i&lt;=n;++i)    if(!entry[i])    q[++tail]=i;    dp[1][1]=0;    while(hhead&lt;=tail){        int p=q[hhead++];        for(rei j=1;j&lt;=n;++j)        for(rei i=n_head[p];i;i=n_edge[i].next)        if(dp[n_edge[i].to][j-1]+n_edge[i].w&lt;dp[p][j])        dp[p][j]=dp[n_edge[i].to][j-1]+n_edge[i].w,prevv[p][j]=n_edge[i].to;        for(rei i=head[p];i;i=edge[i].next){        entry[edge[i].to]--;        if(!entry[edge[i].to])        q[++tail]=edge[i].to;        }       }    for(rei i=n;i;i--)    if(dp[n][i]&lt;=t){        printf(&quot;%d\n&quot;,i);        int tot=0;        int s[maxn],top=0;        for(rei j=n;j;j=prevv[j][i-tot],tot++)        s[++top]=j;        for(rei j=top;j;j--)        printf(&quot;%d &quot;,s[j]);        return 0;    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 拓扑排序 </tag>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
